<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Objetos de los padres</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing object parenting" />
  <meta name="rh-index-keywords" content="Objects - Parents" />
  <meta name="search-keywords" content="parent,child,inheritance,object parenting" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Objetos de los padres</h1>
  <p>Cuando se trabaja con <span class="notranslate">objects</span> en el <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">IDE</span>, se pueden establecer jerarquías <strong>Padre / </strong> Hijo. Esto se hace haciendo clic en el botón &quot;Padre&quot; en el editor de <span class="notranslate">object</span> y luego eligiendo otro <span class="notranslate">object</span> del navegador <span class="notranslate">Asset</span> 
    para que sea el &quot;padre&quot; del que se está editando:</p>
  <p><img>Así pues, cada <span class="notranslate">object</span> en tu proyecto de juego puede tener un padre <span class="notranslate">object</span>, pero ¿qué significa esto? Bueno, cuando un <span class="notranslate">object</span> tiene un padre asignado puede
    compartir código, acciones y eventos con ese padre. Este intercambio se llama &quot;herencia&quot; y un <span class="notranslate">object</span> que tiene un padre se llama &quot;hijo&quot; <span class="notranslate">object</span>. Un hijo no sólo puede compartir código con su padre, sino que puede hacer comprobaciones y ejecutar código
    en el padre <span class="notranslate">objects</span> y éste incluirá automáticamente al hijo <span class="notranslate">objects</span> también, lo que ahorra mucho tiempo y energía.</p>
  <p>Si eso suena complicado, otra forma de ver un padre <span class="notranslate">object</span> es como una manera de &quot;agrupar&quot; <span class="notranslate">objects</span> bajo el mismo paraguas y hacer que compartan ciertas cosas sin perder su propia identidad única. Tal vez eso no aclare demasiado las cosas.
    aclare demasiado las cosas, así que demos algunos ejemplos...</p>
  <p>Digamos que tienes un &quot;jugador&quot; <span class="notranslate">object</span> y cuatro &quot;enemigos&quot; diferentes <span class="notranslate">objects</span>. Ahora, quieres que el jugador muera si toca a cualquiera de estos cuatro <span class="notranslate">objects</span> y esto normalmente implicaría cuatro eventos de colisión diferentes con cuatro conjuntos diferentes de
    acciones o código, uno para cada uno de los enemigos <span class="notranslate">objects</span>. PERO si hacemos un padre <span class="notranslate">object</span> para todos los enemigos, entonces podemos crear un evento de colisión con el padre <span class="notranslate">object</span> solamente y se disparará sin importar cuál de los cuatro enemigos &quot;hijos&quot;
    <span class="notranslate">objects</span> toque al jugador. Muy útil. En el <span data-keyref="GameMaker Name">GameMaker</span> actual <span class="notranslate">object</span> verías algo así:</p>
  <p><img>A la izquierda tenemos cuatro eventos de colisión separados y a la derecha tenemos un solo evento de colisión, ya que hemos creado un
    &quot;padre&quot; <span class="notranslate">object</span> y le hemos asignado todos los enemigos <span class="notranslate">objects</span>. Ten en cuenta que un padre <span class="notranslate">object</span> no tiene que tener ningún evento o código en él...</p>
  <p>Otro ejemplo de la crianza sería si usted tiene un juego en el que desea crear 10 diferentes buscando <span class="notranslate">objects</span> y que todos ellos se comportan de la misma manera. Para ello se crearía un padre <span class="notranslate">object</span> y en que tienen todas sus acciones de comportamiento o el código
    en los eventos requeridos, y luego crearías tus diez <span class="notranslate">objects</span> sin acciones o código, pero diferentes <span class="notranslate">sprites</span>, y les asignarías tu padre <span class="notranslate">object</span>. Ahora, cuando coloques estas instancias en un <span class="notranslate">room</span> todas se comportarán igual, pero tendrán un aspecto diferente,
    ya que &quot;heredarán&quot; los eventos del padre.</p>
  <p>Por último, puede utilizar la crianza para &quot;mezclar y combinar&quot; eventos y comportamientos. Lo ilustraremos con un último ejemplo... Digamos que quieres dos monstruos: uno que se mueva hacia arriba y hacia abajo, y otro que se mueva hacia la izquierda y hacia la derecha, pero también quieres que los
    dos tengan la misma salud, disparen al jugador y le hagan daño si chocan con ellos. En este caso puedes ver que casi todos los eventos deben tener las mismas acciones, excepto uno o dos que gobiernan el movimiento. Así que, de nuevo, podemos hacer que
    un <span class="notranslate">object</span> el padre del otro, pero en este caso también definimos ciertos eventos para el hijo <span class="notranslate">object</span>. Estos eventos &quot;anulan&quot; los eventos padre, lo que significa que cuando un evento para el hijo <span class="notranslate">object</span> contiene acciones, éstas se ejecutan
    en lugar de las acciones contenidas en el evento del padre. Si también quieres ejecutar el evento padre puedes llamar al evento llamado &quot;heredado&quot; usando la función <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>,
    o la acción <span class="notranslate">GML</span> Visual <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a>.</p>
  <p><img>A la izquierda, arriba, está el padre <span class="notranslate">object</span> con 5 eventos en él, y a la derecha puede ver el &quot;hijo&quot; <span class="notranslate">object</span>. El objeto hijo
    también tiene 5 eventos, pero dos de ellos anulan los eventos heredados del padre (los eventos <strong>Step </strong>y <strong>Draw </strong>) y los otros tres están atenuados porque son los eventos heredados del padre. Los eventos heredados
    también tendrán el icono de &quot;anulación del padre&quot; junto a ellos en el Editor de Eventos:</p>
  <p><img>Cuando haga clic en <img> en un evento que ha sido heredado,
    se abrirá el editor de código para mostrar el código padre heredado, pero no podrás editar este código ya que sólo puedes editarlo en el propio <span class="notranslate">object</span> padre. Puedes pulsar el botón derecho del ratón <img> en cualquiera de los eventos padre para abrir el siguiente menú de opciones:</p>
  <p><img>Aquí puede elegir dos <strong>Abrir </strong>el evento padre para inspeccionar el código, o puede elegir <strong>Heredar </strong>el evento
    o <strong>Anular </strong>el evento. Si eliges <strong>Heredar </strong>entonces el editor de código se abrirá con la función <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a> ya
    añadida (o la acción de <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">llamar al evento padre</a> si se utiliza <span class="notranslate">GML</span> Visual). Cualquier otro código que coloques en este evento se ejecutará así como el código que el objeto padre
    tiene. Si eliges <strong>Anular </strong>el evento, entonces la ventana de código también se abrirá, sólo que ahora la función <span class="inline">event_inherited()</span> no será llamada, así que cualquier cosa que añadas aquí se ejecutará <em>en lugar </em>del código
    en el padre <span class="notranslate">object</span>.</p>
  <p class="note"><strong>NOTA</strong>: Desde el editor de código puede navegar rápidamente al padre <span class="notranslate">object</span> haciendo clic en el botón derecho del ratón <img> y seleccionando <strong>Ir a Objeto</strong> en el menú emergente, o (si el evento ha sido anulado) puede seleccionar <strong>Abrir Evento Heredado</strong> para ir directamente a un editor de código con el código del evento padre en él.</p>
  <p>Siempre que apuntes a un padre <span class="notranslate">object</span> en el código, éste se aplicará también a los &quot;hijos&quot; del padre <span class="notranslate">object</span>. Esto sucede cuando, en una acción, se indica que la acción debe aplicarse a las instancias de un determinado <span class="notranslate">object</span>, y en el código
    ocurre cuando se utiliza la sentencia <a href="../../GameMaker_Language/GML_Overview/Language_Features/with.htm"><span class="inline">with()</span></a> declaración. También funcionará así cuando llames a funciones de código, como <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_position.htm"><span class="inline">instance_position()</span></a>,
    <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_number.htm"><span class="inline">instance_number()</span></a>etc... en las que -si se suministra un padre <span class="notranslate">object</span> - todas las instancias del padre <em>y del </em>hijo
    se incluirán en las comprobaciones. Por último, la crianza funciona cuando te refieres a las variables en otros <span class="notranslate">objects</span> también, como en el ejemplo del monstruo de arriba si establezco la velocidad del enemigo 1 a 10, entonces la velocidad del enemigo 2 también irá a diez, ya que es un hijo <span class="notranslate">object</span> del enemigo
    1.</p>
  <p>Generalmente se considera una buena práctica en la mayoría de los casos crear un padre base <span class="notranslate">object</span> y hacer que esta base <span class="notranslate">object</span> contenga todo el comportamiento por defecto, pero nunca utilizar una instancia de la misma en el juego. Es mejor utilizar todos los hijos <span class="notranslate">objects</span> y sólo utilizar el padre en
    situaciones como las que he descrito anteriormente, para colisiones, para referenciar variables, etc... ¡También debes saber que los padres pueden tener padres también! Obviamente no puedes crear un ciclo de &quot;padre 1 es hijo de padre 2 es hijo de padre
    1&quot; pero puedes crear lo que se llama &quot;jerarquía de objetos&quot; donde &quot;<em>padre3 </em>es hijo de <em>padre2 </em>es hijo de <em>padre1</em>&quot;. Esto es extremadamente útil para mantener su juego estructurado y se recomienda encarecidamente
    aprender a utilizar este mecanismo.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Atrás: <a href="../Objects.htm">El editor de <span class="notranslate">Object</span> </a></div>
        <div style="float:right">Siguiente: <a href="Physics_Objects.htm">Objetos de Física</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos los derechos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Parent Objects
Child Objects
parent
child
inheritance
-->
  <!-- TAGS
parent_objects
-->
</body>
</html>