<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guía para el uso de sombreadores</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Guía para el uso de sombreadores</h1>
  <p>Los shaders se utilizan a menudo para crear hermosos efectos gráficos en los juegos. También se encuentran entre las funciones más avanzadas que ofrece <span data-keyref="GameMaker Name">GameMaker</span>, por lo que es necesario que tengas unos conocimientos básicos de programación y de cómo funciona <span data-keyref="GameMaker Name">GameMaker</span> antes de empezar a utilizarlos.</p>
  <p>¿Qué es un <span class="notranslate">shader</span>? Inicialmente se crearon para proporcionar sombreado para la iluminación (de ahí el nombre), pero ahora se utilizan para producir una gran variedad de efectos. El código de <span class="notranslate">Shader</span> es similar al código normal, pero (casi siempre) lo ejecuta la GPU, no la CPU. Esta diferencia tiene sus propias reglas y limitaciones, pero las veremos más adelante.</p>
  <p>Cada <span class="notranslate">shader</span> está formado por dos componentes separados: un <strong>vértice <span class="notranslate">shader</span> </strong>y un <strong>fragmento <span class="notranslate">shader</span> </strong>(también llamado <strong>sombreador de píxeles</strong>). Empecemos por el <span class="notranslate">vertex</span> <span class="notranslate">shader</span>. Cada <span class="notranslate">sprite</span> está formado por un rectángulo, pero a los ordenadores les gusta dibujar triángulos, por lo que esos rectángulos se dividen en dos triángulos (a veces denominados <em>cuadrantes</em>). Esto nos deja con seis vértices (esquinas) por <span class="notranslate">sprite</span>, pero dos de ellos son el mismo, así que sólo debemos preocuparnos por cuatro. Ahora, imaginemos que tenemos un for <span class="notranslate">loop</span> que recorre cada <span class="notranslate">vertex</span> y ejecuta el código dentro de <span class="notranslate">vertex</span> <span class="notranslate">shader</span> para cada uno. Esto nos permite cambiar la posición y el color de <span class="notranslate">vertex</span> antes de pasarlo al fragmento <span class="notranslate">shader</span> ya que el <span class="notranslate">vertex</span> <span class="notranslate">shader</span> se ejecuta antes.</p>
  <p>Así es como se vería:</p>
  <p><img>Para el fragmento <span class="notranslate">shader</span>, puedes imaginar el mismo <span class="notranslate">loop</span> que antes, pero esta vez repasa cada uno de los píxeles de tu <span class="notranslate">sprite</span>, dándote información como la ubicación y el color de ese píxel. En el código de tu fragmento <span class="notranslate">shader</span>, realizas operaciones y cálculos para determinar el color de ese píxel y conseguir el efecto que deseas. Por ejemplo, si quieres que un <span class="notranslate">shader</span> haga que tu <span class="notranslate">sprite</span> sea blanco y negro, entonces calcularías qué tono de gris debe tener cada píxel para crear el efecto.</p>
  <p>Sería algo así:</p>
  <p><img>La razón por la que el código de <span class="notranslate">shader</span> suele ser ejecutado por la GPU es que es más eficiente en ello. Las CPU modernas suelen tener entre dos y ocho núcleos. Cada núcleo puede realizar una tarea a la vez, por lo que al aprovechar varios núcleos, podemos realizar esa cantidad de tareas simultáneamente. En cambio, las GPU modernas pueden realizar miles, e incluso decenas de miles, de tareas al mismo tiempo. Esto es útil para <span class="notranslate">shaders</span> porque podemos ejecutar el código <span class="notranslate">shader</span> de miles de píxeles simultáneamente. La limitación es que sólo tenemos acceso al estado inicial de <span class="notranslate">sprite</span>, por lo que no conocemos las modificaciones realizadas en otros píxeles, ya que no podemos saber con certeza si el código se ha ejecutado en ellos.</p>
  <p class="note"><strong>NOTA</strong>: <span data-keyref="GameMaker Name">GameMaker</span> permite a los usuarios escribir <span class="notranslate">shaders</span> en <strong>GLSL</strong> (Lenguaje OpenGL <span class="notranslate">Shader</span> ), <strong>HLSL</strong> (Lenguaje de alto nivel <span class="notranslate">Shader</span>, utilizado cuando se trabaja con DirectX), y <strong>GLSL</strong> ES (un subconjunto de GLSL que es común en los dispositivos móviles). En este caso utilizamos GLSL <strong>ES</strong> como lenguaje <span class="notranslate">shader</span>, ya que es el que proporciona la mejor compatibilidad entre las plataformas de destino. Por lo general, este es el que siempre querrás usar a menos que tengas necesidades muy específicas y entiendas la limitación de los otros lenguajes de <span class="notranslate">shader</span>. Sin embargo, las matemáticas y las técnicas deberían ser similares entre los tres lenguajes, salvo algunas diferencias de sintaxis aquí y allá.</p>
  <p>El <span class="notranslate">vertex</span> <span class="notranslate">shader</span> se ejecuta en primer lugar, y como hemos explicado anteriormente, se ocupa de los <strong>vértices</strong>. Se utiliza para calcular posiciones, normales y coordenadas de textura. Estos <span class="notranslate">shaders</span> no son especialmente útiles en 2D, ya que cada <span class="notranslate">sprite</span> suele ser un cuadrado, pero se puede utilizar para hacer algo de skewing, scaling, etc... Se vuelve mucho más útil en 3D para los cálculos de iluminación y las deformaciones de la malla. El fragmento <span class="notranslate">shaders</span> es mucho más interesante y es lo que se cubrirá principalmente aquí, ya que el fragmento <span class="notranslate">shader</span> es donde obtenemos información sobre nuestras texturas y podemos ajustar el color final de cada píxel en nuestra imagen.</p>
  <p> </p>
  <h2>Variables de sombreado</h2>
  <p>Si ha creado un <span class="notranslate">shader</span> en <span data-keyref="GameMaker Name">GameMaker</span>, es posible que haya notado las siguientes palabras clave en el <strong>pase por</strong> defecto <span class="notranslate">shader</span>. Estas palabras clave ayudan a <span class="notranslate">shader</span> a entender el propósito y el alcance de cada variable:</p>
  <ul class="colour">
    <li><strong>Atributo</strong>: Son variables que OpenGL pasa al sombreador <strong>de vértices </strong>. Pueden cambiar por <span class="notranslate">vertex</span> y son de sólo lectura. Incluyen información como la posición de <span class="notranslate">vertex</span>, las coordenadas de la textura, el color de <span class="notranslate">vertex</span> y la normalidad de <span class="notranslate">vertex</span>.</li>
    <li><strong>Variable</strong>: Son variables utilizadas para pasar datos entre los sombreadores de <strong>vértices </strong>y de <strong>fragmentos </strong>. Están disponibles para escribir en el <span class="notranslate">vertex</span> <span class="notranslate">shader</span>, pero son de sólo lectura en el fragmento <span class="notranslate">shader</span>.</li>
    <li><strong>Uniformes</strong>: Son variables que cambian por <span class="notranslate">object</span> y son pasadas por el usuario a <span class="notranslate">shader</span>. Pueden ser utilizadas tanto en <span class="notranslate">vertex</span> como en el fragmento <span class="notranslate">shaders</span>, pero son de sólo lectura.</li>
  </ul>
  <p>También verás el uso de <strong>vec</strong> como palabra clave. Esta se utiliza para identificar una variable vectorial en el <span class="notranslate">shader</span> y pronto verás que los vectores son muy importantes cuando se trabaja con <span class="notranslate">shaders</span>. Por eso están implementados como un tipo base en GLSL. Si no estás familiarizado con ellos, son un término matemático representado como una matriz con una sola columna. En programación, solemos representarlos como una matriz donde el número de componentes corresponde a la dimensión. Los vectores bidimensionales y tridimensionales se suelen utilizar para posiciones, coordenadas de textura o colores sin canal alfa, mientras que los cuatridimensionales se utilizan para colores con canal alfa. También podemos especificar si contienen booleanos, enteros o valores de coma flotante. La sintaxis para declarar un vector es la siguiente</p>
  <p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br />
    vec3 secondVec; // Three-dimensional vector of floats<br />
    vec4 thirdVec;  // Four-dimensional vector of floats<br />
    <br />
    bvec3 boolVec;  // Three-dimensional vector of booleans<br />
    ivec4 intVec;   // Four-dimensional vector of integers
  </p>
  <p>Para inicializarlos, podemos utilizar el constructor para crear el vector. Es necesario proporcionar el mismo número de valores que la longitud del vector, pero se pueden mezclar y combinar escalares y vectores más pequeños para alcanzar la longitud objetivo. Aquí hay algunos ejemplos de esto:</p>
  <p class="code">// Simple 2D vector with 2 scalar values<br />
    vec2 firstVec  = vec2(2.0, 1.0);<br />
    // A 4D vector using 2 scalars and a vec2 create the 4 values<br />
    vec4 secondVec = vec4(1.0, firstVec, 0.0);<br />
    // A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values<br />
    vec3 thirdVec  = vec3(secondVec.x, firstVec);</p>
  <p>También podemos asignarles otro vector de la misma longitud (o bien, <em>remover </em>el vector hasta que tenga la longitud adecuada, pero eso lo explicaremos en un momento):</p>
  <p class="code">vec3 firstVec;<br />
    vec3 secondVec = firstVec;<br />
    vec4 thirdVec  = secondVec.xyz;<br />
    vec2 fourthVec = thirdVec.zx;</p>
  <p>Cuando accedemos a los componentes del vector en GLSL, tenemos algunas opciones. La más básica es tratar el vector como un array y acceder a los componentes usando corchetes, así:</p>
  <p class="code">vec4 myVec;<br />
    myVec[0] = 0.0;<br />
    myVec[1] = 1.0;<br />
    myVec[2] = 2.0;<br />
    myVec[3] = 1.0;</p>
  <p>Sin embargo, hay otra forma de acceder a los componentes con la siguiente sintaxis:</p>
  <p class="code">vec4 myVec;<br />
    myVec.x = 1.0;<br />
    myVec.y = 2.0;</p>
  <p>Esto utiliza los nombres de los componentes dentro del vector para acceder a ellos. Puede utilizar x, y, z, o w, para obtener la primera, segunda, tercera o cuarta componente, respectivamente. Nos referimos a este método como <strong>swizzling </strong>porque la siguiente sintaxis también es válida:</p>
  <p class="code">vec4 firstVec;<br />
    vec3 secondVec = firstVec.xyz;<br />
    vec2 thirdVec  = secondVec.zy;<br />
    vec4 fourthVec = thirdVec.yxxy;</p>
  <p>Como puedes ver, podemos utilizar cualquier combinación de hasta cuatro letras para crear un vector de esa longitud. No podemos intentar acceder a un componente que estaría fuera de los límites (por ejemplo, intentar acceder a w en <span class="inline">secondVec</span> o <span class="inline">thirdVec</span>, ya que no tienen un cuarto componente). Además, podemos repetir letras y utilizarlas en cualquier orden, siempre que la variable vectorial a la que se asigne tenga el mismo tamaño que el número de letras utilizadas.</p>
  <p>Por razones obvias, cuando se utiliza swizzle para establecer los valores de los componentes, no se puede utilizar el mismo componente dos veces. Por ejemplo, lo que se muestra a continuación no es válido, ya que se está tratando de establecer el mismo componente a dos valores diferentes:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>Por último, hemos estado utilizando <span class="inline">xyzw</span> como nuestra máscara de swizzle, lo que suele ser el caso cuando se trata de posiciones. Hay dos conjuntos más de máscaras que puede utilizar: <span class="inline">rgba</span> (utilizado para los colores), o <span class="inline">stpq</span> (utilizado para las coordenadas de la textura). Internamente, no hay ninguna diferencia entre estas máscaras, y sólo las usamos para que el código sea más claro en cuanto a lo que el vector representa en esa instancia. Además, no podemos combinar las máscaras de swizzle en la misma operación, por lo que esto no es válido:</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p>
  <p>Han sido muchas definiciones e información, pero conocer estas cosas es necesario para entender el propio <span class="notranslate">shaders</span>.</p>
  <p> </p>
  <h2>Creación de un sombreado</h2>
  <p>Cuando usted crea un <span class="notranslate">shader</span> en <span data-keyref="GameMaker Name">GameMaker</span>, este abrirá dos archivos para usted: un <span class="notranslate">vertex</span> <span class="notranslate">shader</span> (<span class="inline">.vsh</span>) y un fragmento <span class="notranslate">shader</span> (<span class="inline">.fsh</span>). Este es el <span class="notranslate">shader</span> más básico que puede hacer, que toma un <span class="notranslate">sprite</span>, lee la textura, y colorea cada píxel con ese color. Si especifica los colores de <span class="notranslate">vertex</span> al dibujar, esos colores se mezclarán con la textura.</p>
  <p>Repasemos el código de un <span class="notranslate">shader</span> <span class="notranslate">asset</span> recién creado y analicémoslo, empezando por el <span class="notranslate">vertex</span> <span class="notranslate">shader</span>.</p>
  <p class="code">// Passthrough Vertex Shader<br />
    attribute vec3 in_Position;                  // (x,y,z)<br />
    //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br />
    attribute vec4 in_Colour;                    // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;              // (u,v)<br />
    <br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br />
        gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br />
        <br />
        v_vColour = in_Colour;<br />
        v_vTexcoord = in_TextureCoord;<br />
    }
  </p>
  <p>Fuera de la función principal, vemos algunas declaraciones de variables y sus calificadores. Los atributos nos los da <span class="notranslate">GameMaker</span>. Las variables son creadas por el usuario para pasar esa información al fragmento <span class="notranslate">shader</span>. Dentro de la función principal, tenemos los cálculos para encontrar la posición en pantalla del vértice:</p>
  <ul class="colour">
    <li>En primer lugar, creamos un <span class="inline">vec4</span> y lo inicializamos con las componentes de la posición, añadiendo un uno como cuarta componente. En álgebra lineal, la convención es que añadimos un uno a la cuarta componente si el vector representa un punto, o un cero si representa un vector real.</li>
    <li>A continuación, tenemos que añadir este cuarto componente para multiplicarlo por la matriz <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, que es una matriz 4x4. Esta multiplicación proyectará la posición mundial de <span class="notranslate">vertex</span> en coordenadas de pantalla.</li>
    <li>Finalmente pasamos el color <span class="notranslate">vertex</span> y la coordenada de la textura al fragmento <span class="notranslate">shader</span> a través de nuestras variables variables.</li>
  </ul>
  <p>Este <span class="notranslate">shader</span> debe dejarse en paz si no tiene previsto jugar con las posiciones de <span class="notranslate">vertex</span> y no se utilizará en ninguno de los ejemplos que se dan a continuación porque todos los efectos mostrados se crearán utilizando el fragmento <span class="notranslate">shader</span>.</p>
  <p>Echemos ahora un vistazo al fragmento <span class="notranslate">shader</span>:</p>
  <p class="code">// Passthrough Fragment Shader<br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br />
    }
  </p>
  <p>Como se ha explicado anteriormente, la idea de un fragmento <span class="notranslate">shader</span> es devolver el color del píxel actual. Esto se hace asignando a la variable <span class="inline">gl_FragColor</span> el valor del color final. La función <span class="inline">texture2D</span> toma una textura y un <span class="inline">vec2</span> con las coordenadas UV que se quieren comprobar en esa textura, que devuelve un <span class="inline">vec4</span> con el color. En el paso por <span class="notranslate">shader</span>, lo único que estamos haciendo es coger el color de la textura en la coordenada de este píxel y multiplicarlo por el color del <span class="notranslate">vertex</span> asociado a este píxel.</p>
  <p>Ahora que tenemos nuestro primer <span class="notranslate">shader</span>, todo lo que tenemos que hacer para probarlo es crear un <span class="notranslate">object</span> y asignarle un <span class="notranslate">sprite</span>, luego en el <strong>Evento de Dibujo</strong> del <span class="notranslate">object</span> se establece el <span class="notranslate">shader</span> así:</p>
  <p class="code">// Draw Event<br />
    shader_set(shdrColorOverlay);<br />
    draw_self();<br />
    shader_reset();</p>
  <p>Cada llamada al sorteo que hacemos entre <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline">shader_set()</span></a> y <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline">shader_reset()</span></a> se le aplicará el <span class="notranslate">shader</span>. Aquí, estamos dibujando el <span class="notranslate">object</span> <span class="notranslate">sprite</span> con nuestro sombreador de paso:</p>
  <p><img>Como ya habrás adivinado, esto no cambia nada visualmente, ya que se trata de un simple paso a través de <span class="notranslate">shader</span>. Sin embargo, las secciones siguientes describen algunos pasos sencillos que puedes seguir para modificar esto y cambiar la forma en que se dibujará el <span class="notranslate">sprite</span>. Cada una de las secciones muestra un <span class="notranslate">shader</span> diferente que puedes crear y utilizar en tus proyectos, explicando los pasos necesarios para crearlos y por qué estamos haciendo las cosas de la manera en que lo hacemos.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Sombreado de superposición de colores</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Ahora podemos editar la base <span class="notranslate">shader</span> para hacer algo diferente. No tocaremos la parte de <span class="notranslate">vertex</span> <span class="notranslate">shader</span>, y sólo editaremos el fragmento <span class="notranslate">shader</span>, y para empezar haremos una operación muy sencilla, que es hacer que el <span class="notranslate">shader</span> dibuje el <span class="notranslate">sprite</span> usando el color rojo. Lo haremos simplemente cambiando el <span class="inline">gl_FragColor</span> para que sea rojo, así:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      void main()<br />
      {<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br />
      }</p>
    <p class="dropspot">Esto nos dará el siguiente resultado:</p>
    <p class="dropspot"><img>No es exactamente lo que esperábamos. Lo que tenemos que recordar es que cada <span class="notranslate">sprite</span> es, en última instancia, un rectángulo, por lo que, a menos que consideremos la transparencia -que no lo hemos hecho-, este es el resultado que obtendremos.</p>
    <p class="note"><strong>NOTA</strong>: En la imagen de arriba, el rectángulo cambia de tamaño porque la base <span class="notranslate">sprite</span> ha tenido el espacio &quot;vacío&quot; a su alrededor recortado automáticamente cuando se colocó en la página de la textura por <span class="notranslate">GameMaker</span>, por lo que cada cuadro de animación los triángulos que lo componen son de diferentes tamaños para adaptarse al tamaño recortado del cuadro. Si desactivas esta opción, entonces simplemente tendrás un cuadrado rojo sin movimiento en la pantalla.</p>
    <p class="dropspot">Más arriba mencionamos la función <span class="inline">texture2D</span>, y la utilizaremos para tomar el color en el píxel en el que estamos trabajando y obtener la transparencia a partir de él. El valor de retorno de es <span class="inline">texture2D</span> es un <span class="inline">vec4</span>, donde los componentes son el rojo, el verde, el azul y el alfa, en ese orden. Podemos acceder al canal alfa poniendo un punto seguido de un <span class="inline">a</span> o un <span class="inline">w</span> después del nombre de la variable. Esto corresponde a RGBA y XYZW, respectivamente.</p>
    <p class="dropspot">Aquí está el código actualizado:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Ahora estamos asignando un nuevo <span class="inline">vec4</span> a <span class="inline">gl_FragColor</span>, donde el canal rojo está al máximo, los canales verde y azul son cero, y el canal alfa es el mismo que la textura original. El resultado es el siguiente:</p>
    <p class="dropspot"><img>Esto es lo que buscábamos. Hemos sustituido el color de cada píxel por el rojo, pero hemos mantenido el canal alfa intacto.</p>
    <p class="dropspot">Tener que cambiar el <span class="notranslate">shader</span> cada vez que queramos usar un color diferente no es una buena idea, sobre todo porque tendríamos que tener un <span class="notranslate">shader</span> distinto para cada color que queramos. En su lugar, pasaremos la información del color a <span class="notranslate">shader</span> utilizando un <strong>uniforme</strong>. Para hacer esto, primero necesitamos obtener un <strong>puntero </strong>al uniforme. Haremos esto en el <strong>evento Create</strong> de nuestro <span class="notranslate">object</span> que tiene el <span class="notranslate">sprite</span> añadiendo:</p>
    <p class="code">// Create Event<br />
      _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br />
      _color    = [1.0, 1.0, 0.0, 1.0];</p>
    <p class="dropspot">Todo lo que tenemos que hacer es llamar a <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a> para obtener un puntero al uniforme. Los parámetros que necesitamos pasar son el nombre de <span class="notranslate">shader</span> <span class="notranslate">asset</span> (sin comillas porque queremos pasar el ID que nos genera <span class="notranslate">GameMaker</span> ) y el nombre de la variable del uniforme dentro de <span class="notranslate">shader</span>, esta vez como <span class="notranslate">string</span>. Este nombre tiene que coincidir exactamente con el que está dentro del código <span class="notranslate">shader</span> para que funcione. También hemos añadido una variable de color para poder cambiarla en <span class="notranslate">runtime</span> y que recuerde nuestros cambios.</p>
    <p class="dropspot">Ahora el código de nuestro evento draw cambiará ligeramente para pasar la variable uniforme.</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrColorOverlay);<br />
      shader_set_uniform_f_array(_uniColor, _color);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Es el mismo código que antes, pero antes de dibujar nada, tenemos que pasar todos los valores del uniforme al <span class="notranslate">shader</span>. En este caso, estamos pasando el color como un array de floats. En cuanto al <span class="notranslate">shader</span>, lo cambiaremos para incluir el uniforme y utilizarlo, por lo que se convierte:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      uniform vec4 u_color;<br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(u_color.rgb, texColor.a);<br />
      }</p>
    <p class="dropspot">Declaramos una variable con el mismo nombre que en el create <span class="notranslate">shader</span> (<span class="inline">u_color</span>) y la pasamos como los tres primeros componentes del vector <span class="inline">gl_FragColor</span>, aprovechando el swizzling. Si compilamos de nuevo, deberíamos ver esto:</p>
    <p class="dropspot"><img>Ahora el <span class="notranslate">shader</span> es mucho más útil y reutilizable. Depende de ti añadir más funcionalidad si lo necesitas para establecer el color (usando la variable <span class="inline">_color</span>) durante <span class="notranslate">runtime</span>.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Sombreado en blanco y negro</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Hacer un <span class="notranslate">shader</span> en blanco y negro es una buena manera de aprender cómo funciona <span class="notranslate">shaders</span>, y muchos principiantes empiezan intentando hacerlo, ya que conceptualmente es bastante sencillo: coger cada píxel y asignarle un tono de gris. ¿Pero es sencillo? No del todo...</p>
    <p class="dropspot">Cuando se utiliza el color RGB, si los tres componentes tienen el mismo valor, se obtiene un tono gris. El enfoque ingenuo para crear un <span class="notranslate">shader</span> para utilizar esta idea sería sumar los tres canales de color (rojo, verde y azul) y luego dividirlo por tres. Después asignarías el valor a los tres canales, creando así un tono gris. Este es el aspecto de ese fragmento <span class="notranslate">shader</span>:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br />
          gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Una cosa que habrás notado es que en el código de <span class="inline">gl_FragColor</span>, estamos multiplicando el <span class="inline">vec4</span> con algo llamado <span class="inline">v_vColour</span>. Esta es una variable pasada por el <span class="notranslate">vertex</span> <span class="notranslate">shader</span> que nos dice el color del <span class="notranslate">vertex</span> asociado a este píxel. Siempre es una buena idea multiplicar el color final calculado por el color de <span class="notranslate">vertex</span>. En la mayoría de los casos, no hará nada, pero si ha cambiado el color de <span class="notranslate">vertex</span> en <span class="notranslate">GML</span>, esto lo reflejará (usando funciones como <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> o <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> para cambiar el <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">En cuanto al evento del sorteo, es bastante sencillo ya que no tenemos un uniforme para pasar:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrBlackAndWhite);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Recopilemos y veamos lo que tenemos.</p>
    <p class="dropspot"><img>Esto ya se ve muy bien, ¿verdad? Bueno, sí y no... hay una solución que es más "correcta", ya que en lugar de sumar los componentes y dividir por tres, multiplicamos cada componente por los valores estándar NTSC para el blanco y el negro. Aquí está el código del fragmento modificado <span class="notranslate">shader</span>:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br />
          gl_FragColor = vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Utilizamos el producto punto como una forma de abreviar la multiplicación de cada componente de <span class="inline">texColor</span> con los pesos correctos y luego los sumamos. Si no estás familiarizado con el producto punto, esto es esencialmente lo que está sucediendo:</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p>
    <p class="dropspot">Al final, se parece mucho, pero es técnicamente más correcto.</p>
    <p class="dropspot"><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Sombreado del arco iris</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Nuestro último ejemplo de <span class="notranslate">shader</span> es muy divertido y puede utilizarse para dar vida a textos, botones y otras cosas. Empezaremos de forma sencilla y añadiremos funcionalidad gradualmente ya que este <span class="notranslate">shader</span> es altamente personalizable. Hay mucho que cubrir en este caso, así que si te sientes un poco perdido o confundido, por favor vuelve a leer algunas de las secciones anteriores.</p>
    <p class="dropspot">Lo primero que queremos hacer es colorear los píxeles con cada tono, dependiendo de la posición horizontal del píxel. La forma de hacer esto es establecer la posición x para que sea el tono y luego convertir del formato HSV (tono, saturación, brillo) al formato RGB (rojo, verde y azul). Para ello, tendremos que escribir una función de ayuda en nuestro fragmento <span class="notranslate">shader</span> que toma los valores HSV y devuelve un vector RGB. Utilizaremos una única función que haga esto sin necesidad de ninguna sentencia <span class="inline">if</span>, ya que el uso de condicionales en el código de <span class="notranslate">shader</span> hace que <span class="notranslate">shaders</span> sea <em>muy </em>lento, y debería evitarse.</p>
    <p class="dropspot">Este es el aspecto de <span class="notranslate">shader</span> en esta fase:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Aquí hay un poco más que en los ejemplos anteriores, pero la mayor parte debería ser bastante obvia para ti ahora. En primer lugar, está nuestra función <span class="inline">hsv2rgb</span>, que toma un <span class="inline">vec3</span> con nuestro color HSV y devuelve otro <span class="inline">vec3</span> con nuestra conversión RGB. En la función principal, empezamos creando nuestro color HSV, donde el tono es nuestra posición x, y dejaremos la saturación y el brillo como 1.0 por ahora. A continuación, obtenemos el alfa de la textura para que sólo coloree nuestro personaje <span class="notranslate">sprite</span> y no todo el rectángulo <span class="notranslate">sprite</span> (como hicimos en el ejemplo de superposición de colores, más arriba). Por último, establecemos el color de nuestro fragmento para que sea nuestro color HSV convertido a RGB con el alfa, multiplicado por el color de <span class="notranslate">vertex</span> (es una buena práctica hacer esto siempre).</p>
    <p class="dropspot">En cuanto a nuestro código de sorteo, es trivial por el momento:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Veamos lo que tenemos:</p>
    <p class="dropspot"><img>Estamos cerca de lo que queremos, pero hay un problema: no estamos viendo todos los colores a la vez en cada fotograma de la animación, y los colores parecen cambiar aleatoriamente. La razón es que asumimos que <span class="inline">v_vTexcoord</span> nos dio las coordenadas de <span class="notranslate">sprite</span>, comenzando en la esquina superior izquierda (0,0) y terminando en la esquina inferior derecha (1,1), lo que es estándar en <span class="notranslate">shaders</span>. Sin embargo, para la optimización, <span class="notranslate">GameMaker</span> rellena tantas texturas juntas como puede caber en lo que se llama una <a href="../Settings/Texture_Information/Texture_Pages.htm">página de textura,</a> y debido a eso, así es como nuestra textura se ve realmente:</p>
    <p class="dropspot"><img>Como se ha explicado anteriormente, <span class="inline">v_vTexcoord</span> nos da las coordenadas absolutas de la <span class="notranslate">sprite</span> dentro de toda esta página de textura, pero lo que queremos es un valor de 0.0 a 1.0 que sólo cubra nuestro <span class="notranslate">sprite</span> actual. Este proceso se llama <strong>normalizar</strong> (obtener un valor y traducirlo a un rango de 0 a 1). Para normalizar nuestros valores horizontales, necesitamos conocer los valores de x0 y x1 en la imagen anterior. Por suerte, <span class="notranslate">GameMaker</span> tiene una función que nos da la ubicación de cada esquina en nuestro <span class="notranslate">sprite</span> dentro de la página de la textura. Primero, necesitamos ir al evento Create y crear un uniforme para pasar estos datos al shader:</p>
    <p class="code">// Create Event<br />
      _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">Y modificamos el evento draw para obtener los valores y luego pasarlos al shader:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">La función <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> toma un <span class="notranslate">sprite</span> y un índice, y devuelve una matriz con toneladas de información, como las coordenadas de cada esquina, cuántos píxeles se recortaron para optimizarla, etc. A nosotros nos interesan dos de esos valores: las coordenadas izquierda y derecha de <span class="notranslate">sprite</span>, que se almacenan en <span class="inline">uv[0]</span> y <span class="inline">uv[2]</span> respectivamente. En el fragmento <span class="notranslate">shader</span>, utilizaremos ahora esos valores para calcular la posición horizontal normalizada de esta manera:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3(pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Aquí añadimos la variable uniforme en la parte superior del archivo con el mismo nombre que usamos en el evento Create. A continuación, calculamos la posición horizontal normalizada trasladando nuestra coordenada actual <span class="inline">x</span> al origen ( <span class="inline">v_vTexcoord.x - u_uv[0]</span>) y luego la dividimos por el ancho de la <span class="notranslate">sprite</span> para hacer el rango de 0 a 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">El resultado es:</p>
    <p class="dropspot"><img>¡Ya está! Esto es exactamente lo que queríamos. Podemos ver todos los colores del espectro dentro de nuestro <span class="notranslate">sprite</span>.</p>
    <p class="dropspot">Puede que estés contento con eso, pero podemos divertirnos un poco más con esto <span class="notranslate">shader</span>. ¿Y si añadimos un desplazamiento de los colores basado en el tiempo para producir el movimiento? Para ello, necesitaremos dos variables adicionales para la <strong>velocidad </strong>y el <strong>tiempo</strong>. También necesitaremos dos uniformes más, uno para cada una de las nuevas variables, por lo que el Evento Crear se convierte:</p>
    <p class="code">// Create Event<br />
      _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _time  = 0;<br />
      _speed = 1.0;</p>
    <p class="dropspot">También necesitamos aumentar el tiempo en cada fotograma, por lo que en el Evento de Paso añadimos:</p>
    <p class="code">// Step Event<br />
      _time += 1 / room_speed;</p>
    <p class="dropspot">Vayamos ahora al evento draw para enviar estos uniformes al shader:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Por último, volveremos a nuestro <span class="notranslate">shader</span> para utilizar realmente estas variables ahora. Lo que haremos es multiplicar la velocidad con el tiempo y añadirlo a la posición, así:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Si has hecho todo correctamente, deberías ver algo así:</p>
    <p class="dropspot"><img>Para terminar este <span class="notranslate">shader</span>, añadiremos algunos uniformes más para personalizarlo aún más. Los dos primeros son para controlar la saturación y el brillo. El siguiente lo llamaremos &quot;sección&quot; y su función es permitir al usuario pasar un número entre cero y uno para determinar qué porcentaje de todo el espectro vemos a la vez. Por último, añadiremos una variable llamada &quot;mix&quot;, que especificará cuánto queremos mezclar nuestro color <span class="notranslate">shader</span> con el color original de la textura (1.0 es todo arco iris, 0.0 es todo textura). Como siempre, empecemos por añadir las variables al evento Create:</p>
    <p class="code">// Create Event<br />
      _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _uniSection    = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br />
      _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br />
      _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br />
      _uniMix        = shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br />
      <br />
      _time  = 0;<br />
      _speed = 1.0;<br />
      _section = 0.5;<br />
      _saturation = 0.7;<br />
      _brightness = 0.8;<br />
      _mix = 0.5;
    </p>
    <p class="dropspot">Nuestro evento de sorteo cambia para incluir estos uniformes así:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      shader_set_uniform_f(_uniSaturation, _saturation);<br />
      shader_set_uniform_f(_uniBrightness, _brightness);<br />
      shader_set_uniform_f(_uniSection, _section);<br />
      shader_set_uniform_f(_uniMix, _mix);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">En cuanto a la <span class="notranslate">shader</span>, necesitamos pasar la saturación y el brillo al color, que afectará al color generado por nuestra función de ayuda. La sección necesita ser multiplicada por nuestra posición para reducir el rango. También cogeremos todo el color de la textura, para poder calcular nuestro color final mezclando el color de la textura con la conversión RGB de nuestro color. El último parámetro de la función de mezcla determina la cantidad del segundo color que queremos añadir. Este es nuestro código final <span class="notranslate">shader</span>:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      uniform float u_saturation;<br />
      uniform float u_brightness;<br />
      uniform float u_section;<br />
      Uniform float u_mix;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          <br />
          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br />
        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br />
          <br />
          gl_FragColor = v_vColour * finalCol;<br />
      }
    </p>
    <p class="dropspot">Y nuestro resultado final es éste.</p>
    <p class="dropspot"><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Este es el final de esta breve guía y ahora deberías entender mejor cómo funciona <span class="notranslate">shaders</span> y algunos de los usos que se le pueden dar. Deberías tomarte tu tiempo para jugar con los <span class="notranslate">shaders</span> que has creado siguiendo esta guía, y tratar de experimentar con ellos para hacer otras cosas - ¿qué tal si creas un desenfoque <span class="notranslate">shader</span>, o un <span class="notranslate">shader</span> que haga una pantalla monocromática al estilo gameboy? - ya que <span class="notranslate">shaders</span> son una herramienta increíblemente poderosa para añadir complejidad visual y estilo a tus juegos.</p>
  <p class="note">Nos gustaría agradecer a <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> y a <strong>Amazon</strong> por permitirnos reproducir esta guía. Puedes encontrar la versión original en el <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">blog de desarrolladores</a> de Amazon.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Atrás: <a href="Additional_Information.htm">Información adicional</a></div>
        <div style="float:right">Siguiente: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Guía para la construcción de primitivos y <span class="notranslate">Vertex</span> </a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos los derechos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>