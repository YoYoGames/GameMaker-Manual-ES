<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Movimiento y controles</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Movimiento y controles</h1>
  <p>La <a href="Drawing.htm">sección</a> anterior de esta Guía de Inicio Rápido daba algunos ejemplos para dibujar cosas en la pantalla, pero dibujar cosas no sirve de mucho si no puedes también moverlas... así que en esta sección te daremos algunos ejemplos de movimiento para tu <span class="notranslate">objects</span>, así como algunos esquemas de control básicos para diferentes tipos de juegos. Todos los ejemplos se dan usando <span class="notranslate">GML</span> Visual así como el Código <span class="notranslate">GML</span>, así que puedes usar el que te resulte más cómodo. Ten en cuenta que no vamos a explicar las cosas con demasiada profundidad aquí, ya que queremos que empieces a hacer cosas lo más rápido posible, así que te animamos a que explores los enlaces a medida que avanzas y a que utilices la función de &quot;búsqueda&quot; del manual para buscar información adicional sobre cualquier cosa de la que no estés seguro.</p>
  <p>Antes de seguir adelante, es posible que quieras crear un nuevo proyecto (ya sea <span class="notranslate">GML</span> o <span class="notranslate">GML</span> Visual) desde la <a href="../Introduction/The_Start_Page.htm">página de inicio</a>, y añadir (o crear) unos cuantos <span class="notranslate">sprites</span> así como uno o dos <span class="notranslate">object</span> -ya que te daremos algo de código que puedes probar usando estos- y asegurarte de que el proyecto tiene un <span class="notranslate">room</span> para colocar instancias. No te preocupes demasiado por el aspecto de los <span class="notranslate">sprites</span> que hagas, ya que incluso un simple cuadrado blanco servirá, y una vez que tengas todo listo puedes empezar a trabajar en los ejemplos que aparecen a continuación.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Muévete hacia el ratón</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Una de las formas más sencillas de hacer que un <span class="notranslate">object</span> se mueva e interactúe con el jugador es utilizar el ratón, y en este ejemplo le mostraremos cómo utilizar un código básico para hacer que un <span class="notranslate">object</span> se mueva hacia donde el usuario haya pulsado el botón izquierdo del ratón <img>.</p>
    <p class="dropspot">Para empezar, abra un <span class="notranslate">object</span>, asígnele un <span class="notranslate">sprite</span>, y luego déle un <strong>evento global de ratón izquierdo hacia abajo</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Usamos los eventos <strong>globales </strong>del ratón porque detectan un clic en cualquier parte de la <span class="notranslate">room</span>, mientras que los eventos regulares del ratón sólo detectarán un clic si el ratón realmente hace clic dentro del <a class="glossterm" data-glossterm="cuadro delimitador" href="#">cuadro delimitador de</a> la instancia. En este evento queremos añadir estas acciones o código:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Aquí le estamos diciendo a la instancia que se mueva hacia una posición en la pantalla, en este caso la posición &quot;<span class="inline">mouse_x</span>&quot; y &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; y &quot;<span class="inline">mouse_y</span>&quot; son<span class="glossextra">variables</span> <strong>incorporadas </strong> que siempre mantienen la posición actual del cursor del ratón). El <span class="notranslate">GML</span> Visual hace esto estableciendo el &quot;<span class="inline">direction</span>&quot; y el &quot; <span class="inline">speed</span>&quot; <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Variables de la instancia</strong></a>mientras que el <span class="notranslate">GML</span> lo hace mediante la función <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (ésta también establece las variables <span class="inline">speed </span>y <span class="inline">direction </span>, sólo que en una función única y fácil de usar).</p>
    <p class="dropspot">Coloque una instancia de este <span class="notranslate">object</span> en un <span class="notranslate">room</span> y luego pulse el botón de reproducción <img>, después haga clic en <img> alrededor del <span class="notranslate">room</span> para que la instancia se mueva hacia el ratón:</p>
    <p class="dropspot"><img>Muy bien. La instancia de la <span class="notranslate">object</span> ahora se mueve hacia el lugar donde has hecho clic, y si mantienes pulsado el botón, la instancia seguirá siguiendo el cursor del ratón. Sin embargo, hay un problema... Después de hacer clic una vez y soltarlo, la instancia seguirá moviéndose y acabará abandonando el <span class="notranslate">room</span>. Hay varias maneras de arreglar esto, y la que elijas dependerá de lo que quieras hacer, pero la solución más fácil por ahora es simplemente añadir un evento <strong>global de liberación</strong> del botón del ratón, así que añádelo ahora a <span class="notranslate">object</span> y dale este código:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">Con esto, la instancia sólo seguirá el cursor del ratón mientras se mantenga pulsado el botón del ratón, y cuando sueltes el botón dejará de moverse. Pulsa Play <img> y pruébalo ahora.</p>
    <p class="dropspot">Antes de dejar este ejemplo, hay una última cuestión que debemos resolver... Si haces clic y <em>mantienes </em>el botón del ratón, pero no mueves el cursor, la instancia se moverá hacia el cursor y luego &quot;vibrará&quot; alrededor de él. Esto se debe a que la instancia se está moviendo más rápido que 1 píxel a la vez y por lo tanto &quot;sobredispara&quot; la posición y luego trata de moverse hacia atrás, y luego sobredispara de nuevo, etc ... (hacer la velocidad de movimiento 5 o algo así para ver el problema si no es inmediatamente obvio).</p>
    <p class="dropspot"><img>Para solucionarlo tenemos que añadir un <strong>evento de paso</strong> a la <span class="notranslate">object</span> con este código:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if (_dist &lt;= speed) <br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Aquí sólo comprobamos la distancia de la instancia a la posición del ratón, y si es igual o menor que la velocidad actual, ponemos la velocidad a 0. Esto hace que la instancia se detenga cuando está lo suficientemente cerca de la posición del ratón, y no tenemos ese desagradable problema de &quot;vibración&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Movimiento de 4 y 8 direcciones con el teclado</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Justo al principio de esta</a> guía, te mostramos la siguiente acción y código para mover una instancia a la derecha dos píxeles en cada paso del juego:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Este tipo de movimiento se llama movimiento <strong>posicional </strong>, ya que esencialmente estamos recogiendo la instancia y colocándola de nuevo en una nueva posición cada vez que se ejecuta el código. Lo que vamos a hacer en este ejemplo es mostrar cómo utilizar este tipo de movimiento para mover una instancia en 4 direcciones: arriba, abajo, izquierda y derecha.</p>
    <p class="dropspot">Para empezar, abre un <span class="notranslate">object</span> y asígnale un <span class="notranslate">sprite</span>. Ahora, podríamos añadir en este punto varios Eventos de <strong>Teclado</strong>, y en cada uno de ellos hacer que la instancia se mueva en la dirección deseada, sin embargo, sólo queremos que el jugador pueda moverse en una dirección a la vez y hacer esto con sólo los eventos de teclado es un poco más complicado que hacerlo usando código. En su lugar usaremos el <strong>Evento Paso</strong> - que deberías añadir ahora a la <span class="notranslate">object</span> - con las siguientes acciones o código para usar las Teclas de Flecha para moverse:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Estamos utilizando una estructura &quot; <span class="inline">if... else if... else if...</span>&quot; para asegurar que la instancia sólo se moverá en una dirección a la vez, y por lo tanto la instancia sólo debe ser capaz de moverse hacia arriba, abajo, izquierda o derecha, pero no en diagonal. Coloca una instancia del <span class="notranslate">object</span> en un <span class="notranslate">room</span> y pulsa el botón <strong>Play </strong> <img> para probarlo ahora. Si todo ha ido correctamente, deberías tener algo así:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Podemos modificar este código para convertir el movimiento de 4 direcciones en movimiento de 8 direcciones fácilmente también... simplemente elimina los comandos &quot; <span class="inline">else</span>&quot; de los bloques de código para que todo se vea así:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Ahora, al pulsar el botón de <strong>reproducción </strong> <img> se verá algo así:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Una última cosa que vale la pena señalar para los usuarios que codifican con <span class="notranslate">GML</span>... Cuando se utiliza <span class="notranslate">GML</span> Visual se puede seleccionar la tecla del teclado que se desea utilizar de una lista desplegable, pero con <span class="notranslate">GML</span> no es tan sencillo. Hay un número de <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">constantes</a> de teclado que puedes usar - como las constantes de las teclas de flecha mostradas en el código de arriba - pero <em>no </em>hay constantes para las teclas alfanuméricas. Éstas se manejan de forma ligeramente diferente, y requieren el uso de la función <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. El código de abajo muestra cómo funcionaría usando WASD en lugar de las teclas de flecha:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;D&quot;))) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;W&quot;))) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;S&quot;))) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Movimiento del Gamepad</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Ya hemos hablado del movimiento del ratón y del teclado, así que es hora de hablar del movimiento <strong>del gamepad </strong>. Ahora, no vamos a cubrir el d-pad, ya que realmente funciona igual que el uso del teclado (simplemente cambiar las funciones del teclado en el ejemplo anterior para <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> o <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">si el botón del Gamepad está abajo</a>), así que en este ejemplo veremos el uso del stick analógico para el movimiento.</p>
    <p class="dropspot">Para empezar, tenemos que detectar el gamepad que se está utilizando. Los gamepads tienen un valor de ID de 0 a 11, por lo que utilizaremos un comando &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> para detectar el ID de cualquier gamepad conectado y almacenar este valor de ID en una variable para su uso futuro. Como sólo queremos detectar el primer gamepad que se conecte y no todos ellos, utilizaremos el comando &quot; <span class="inline">break</span>&quot; después de detectar un gamepad para que &quot;rompa&quot; el <span class="notranslate">loop</span> (por ejemplo, si el primer gamepad conectado es de ID 4, entonces el <span class="notranslate">loop</span> sólo se ejecutará 5 veces, comprobando los valores de ID 0 - 4 y luego rompiendo el <span class="notranslate">loop</span> cuando se encuentre el gamepad). Así que, haz (o abre) un <span class="notranslate">object</span>, asígnale un <span class="notranslate">sprite</span>, y luego añade un <strong>evento Create</strong> con lo siguiente:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if gamepad_is_connected(i)<br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Fíjate en que en el código anterior establecemos el <strong> <a class="glossterm" data-glossterm="zona muerta" href="#">zona muerta</a> </strong>para el gamepad. Esto se debe a que los sticks analógicos en diferentes marcas de gamepads tendrán diferente sensibilidad, y a veces pueden ser tan sensibles que si no se establece una zona muerta entonces pueden causar un movimiento no deseado en sus juegos. Así que establecemos la zona muerta a un valor como 0,2 para decirle a <span data-keyref="GameMaker Name">GameMaker</span> que ignore cualquier valor de los sticks del gamepad por debajo de ese valor <a class="glossterm" data-glossterm="absoluto" href="#">absoluto</a>.</p>
    <p class="dropspot">Para añadir el movimiento real, necesitaremos un <strong>Evento de Paso</strong>, así que añádelo ahora y dale el siguiente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepads[0], gp_axislh);<br />
          var _v = gamepad_axis_value(gamepads[0], gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Aquí estamos comprobando el movimiento horizontal o vertical del stick <em>izquierdo </em>. Las funciones del eje devuelven un valor entre -1 y 1, así que para el eje horizontal -1 es izquierda, 0 es no moverse y 1 es derecha, y para el eje vertical es -1 para arriba, 0 para no moverse y 1 para abajo. Ten en cuenta también que los valores están <em>entre </em>-1 y 1, por lo que -por ejemplo- el eje horizontal podría devolver un valor de 0,5, lo que significa que el stick está a medio camino entre la posición de &quot;reposo&quot; y totalmente empujado hacia la derecha. Por esta razón, multiplicamos el valor por 4 (puedes multiplicar por cualquier valor realmente, dependiendo de la velocidad a la que quieras que se mueva la instancia) - significa que la velocidad de la instancia variará dependiendo de cuánto movimiento se haya hecho en el eje del stick.</p>
    <p class="dropspot">Coloca una instancia de este <span class="notranslate">object</span> en un <span class="notranslate">room</span> y presiona el botón <strong>Play </strong><strong> <img></strong>y muévete con el stick izquierdo de tu gamepad conectado. Deberías ver algo así:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Movimiento avanzado en 8 direcciones</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">En este último ejemplo, vamos a volver a revisar nuestro código de movimiento de 8 direcciones y abordar un problema que tiene, que es que el movimiento diagonal es realmente más rápido que el movimiento arriba/abajo/izquierda/derecha. Esto es simplemente porque cuando te mueves en diagonal, te mueves a lo largo de la hipotenusa de un triángulo rectángulo creado por los valores de movimiento x/y:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Para que quede más claro lo que ocurre, eliminemos todo el texto y <span class="notranslate">sprites</span> y mostremos simplemente la misma línea de movimiento girada 45° para que quede horizontal:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Como puedes ver, la diferencia es bastante obvia, y si la instancia se mueve más de 1 o 2 píxeles por paso, entonces se hace muy notorio que el movimiento diagonal es <em>mucho </em>más rápido. Entonces, ¿cómo limitamos esto? Hay varias maneras de hacerlo, pero vamos a concentrarnos en una de ellas, porque introduce un par de funciones y conceptos que te serán útiles más adelante en tus juegos.</p>
    <p class="dropspot">Para ello, vamos a tener que almacenar los valores de entrada de las teclas pulsadas de forma independiente en<span class="glossextra">variables</span>, y luego comprobarlas y moverse según la combinación de teclas que se hayan pulsado. Así que, para esto necesitarás un <span class="notranslate">object</span> con un <span class="notranslate">sprite</span> asignado, y tendrás que darle un <strong>Evento de Paso</strong> con las siguientes acciones o código:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">NOTA</span> Hemos dividido las acciones visuales de arriba en dos columnas para que sea más fácil de visualizar, pero en el editor visual, se colocarán consecutivamente.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Tendremos que añadir algo más de código para poder movernos, pero antes de hacerlo, vamos a explicar esto un poco. Queremos convertir izquierda/derecha/arriba/abajo en valores de velocidad horizontales y verticales equivalentes, así que para hacer eso estamos obteniendo el valor de cada tecla y luego haciendo algunas matemáticas básicas en él para obtener los valores de velocidad. Esto funciona porque si una tecla está siendo presionada entonces la acción o función de control devolverá &quot;1&quot;, y si <em>no </em>está siendo presionada, entonces la función devolverá 0. Así, si - por ejemplo - la derecha está siendo presionada, tienes &quot;1 - 0 = 1&quot; para el &quot; <span class="inline">_hspd</span>&quot;, y si la izquierda está siendo presionada tienes &quot;0 - 1 = -1&quot; para el &quot; <span class="inline">_hspd</span>&quot; (y si ambos son presionados entonces es &quot;1 - 1 = 0&quot;, por lo que la instancia no se moverá). Recuerde que en un <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">room</span>, para moverse a la derecha sumamos a la posición <span class="inline">x </span>y para moverse a la izquierda restamos, por lo que este código nos dará un valor positivo o negativo que podemos sumar o restar para movernos horizontal o verticalmente dependiendo de la entrada del teclado.</p>
    <p class="dropspot">Ahora podemos añadir el código que realmente mueve la instancia, por lo que - todavía en el <strong>evento de paso</strong>, y después del código anterior - añadir esto:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">El código anterior comprueba primero si una de las dos<span class="glossextra">expresiones</span> es verdadera, es decir, si las variables de velocidad horizontal o vertical no son 0. Observe cómo la comprobación &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> utiliza el símbolo &quot; <span class="inline">||</span>&quot;. Esto significa &quot; <span class="inline">or</span>&quot; en programación, por lo que - en lenguaje llano - se está comprobando</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">Puede <span class="notranslate">string</span> múltiples expresiones juntas en las comprobaciones &quot; <span class="inline">if</span>&quot; de esta manera, y hay múltiples maneras diferentes en que esas expresiones pueden ser evaluadas (para más información por favor vea la sección de <strong>Expresiones</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">aquí</a>).</p>
    <p class="dropspot">La siguiente sección de código almacena un valor para la velocidad de movimiento real en una variable y luego obtiene una dirección usando los valores de <span class="inline">_hspd </span>y <span class="inline">_vspd </span>, que pueden ser -1, 0 o 1. La función de dirección comprueba desde (0, 0) ya que no estamos usando coordenadas <span class="notranslate">room</span>, y en su lugar queremos que se evalúe como una dirección de 0° a 360° basada en los valores de las variables. El siguiente diagrama ilustra lo que sucede mejor que intentar explicarlo con palabras:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">NOTA</span> La dirección en <span data-keyref="GameMaker Name">GameMaker</span> se calcula <strong>en sentido contrario a las agujas del reloj</strong>, por lo que 0° y 360° son a la derecha, 90° es arriba, 180° es a la derecha y 270° es abajo.</p>
    <p class="dropspot">Por último, utilizamos el <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> y <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> para mover realmente la variable. Se trata de funciones <strong> <a class="glossterm" data-glossterm="vector" href="#">vector</a>  </strong>que toman una longitud (distancia) y una dirección y luego calculan la nueva posición en el eje dado basándose en estos valores (ver las descripciones de las funciones para una explicación más detallada).</p>
    <p class="dropspot">Es mucho para asimilar de una vez, y no te preocupes si no lo entiendes todo. Lo harás con el tiempo. Todo lo que queda por hacer es añadir una instancia de este <span class="notranslate">object</span> a un <span class="notranslate">room</span>, y luego pulsar el botón <strong>Play </strong><strong> <img></strong>y deberías obtener un movimiento suave como la seda en 8 direcciones sin ninguno de los problemas relacionados con el movimiento en diagonal:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Con estos ejemplos -y los anteriores de dibujo- esperamos que hayas entendido lo suficiente como para empezar a hacer tus propios proyectos. La última página de esta Guía de inicio rápido contiene un resumen de algunas de las cosas que has aprendido, así como enlaces a materiales de aprendizaje adicionales.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Volver: <a href="../Content.htm">Index</a></div>
        <div style="float:right">Siguiente: <a href="Summary.htm">Resumen</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos los derechos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>