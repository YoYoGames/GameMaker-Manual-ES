<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Palabras clave de la instancia</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Palabras clave de la instancia</h1>
    <p>Para facilitar ciertas cosas en <span data-keyref="GameMaker Name">GameMaker</span>, puede utilizar una de varias <b>palabras</b> clave de instancia en su código (ya sea <span class="notranslate">GML</span> o <span class="notranslate">GML</span> Visual). Estas palabras clave se utilizan principalmente para identificar instancias - y en algunos casos <span class="notranslate">structs</span> - en diferentes situaciones, y cada una se explica en el texto a continuación.</p>
    <p>Tenga en cuenta que todas las palabras clave dadas están representadas por valores enteros <strong>negativos</strong> internamente, por lo que se debe tener cuidado al asignar o comprobar los valores de las variables contra o con estas palabras clave, ya que puede obtener resultados inesperados más tarde como <span data-keyref="GameMaker Name">GameMaker</span> interpreta el valor que ha utilizado como otra cosa. También debe tener en cuenta que el uso de los valores enteros directamente en lugar de las palabras clave en su código <b>no</b> se <b>recomienda en absoluto</b> y podría causar problemas más adelante.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palabra clave</th>
            <th>Descripción</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>La instancia/estructura que está ejecutando el bloque de código actual.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> puede utilizarse para identificar el <span class="notranslate">struct</span> actual o la instancia que está en el ámbito del bloque de código actual. Por ejemplo:</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">En este ejemplo puedes ver que tenemos una variable <i>local</i> llamada <span class="inline">val</span> y queremos que establezca la variable de <i>instancia</i> con el mismo nombre en la instancia recién creada <span class="notranslate">object</span>. Para identificar la variable de instancia correctamente y decirle a <span data-keyref="GameMaker Name">GameMaker</span> que la establezca en la instancia que llama al bloque de código, utilizamos la palabra clave <span class="inline">self</span>. En la mayoría de los casos también se puede utilizar la variable de instancia incorporada <span class="inline">id</span> en lugar de <span class="inline">self</span>, pero <span class="inline">self</span> ofrece ciertas ventajas. Para empezar, es más rápido para el compilador identificar la instancia (o <span class="notranslate">struct</span>) utilizando <span class="inline">self</span> en lugar de <span class="inline">id</span>, ya que el valor <span class="inline">id</span> pasa por la tabla de búsqueda de instancias mientras que <span class="inline">self</span> no lo hace. En segundo lugar, para aquellos que hacen <span class="notranslate">extensions</span>, es muy útil para asegurar el correcto alcance de las variables, ya que es posible que un proyecto que utiliza un <span class="notranslate">extension</span> pueda tener una variable de alcance global o algo con el mismo nombre que una variable en el <span class="notranslate">extension</span>.</p>
      <p class="note"><strong>NOTA</strong>: La palabra clave <span class="inline">self</span> <strong>no es un </strong>atajo para el valor de ID real de una instancia o <span class="notranslate">struct</span> y sólo debe utilizarse en el contexto explicado anteriormente. Si necesita el valor <strong>de </strong>ID de una instancia, debe utilizar <span class="inline">self.id</span>, por ejemplo:</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">También cabe destacar que <span class="inline">self</span> también puede utilizarse dentro de <a href="Structs.htm">los structs</a> -en circunstancias muy específicas- para referenciar variables miembro para el <span class="notranslate">struct</span>.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palabra clave</th>
            <th>Descripción</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>La otra instancia involucrada en un evento de colisión, en una función <span class="inline">with</span> o en una función.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">La palabra clave especial <span class="inline">other</span> tiene múltiples formas de ser usada para referenciar una instancia específica (y en algunos casos, un <span class="notranslate">struct</span>): puede ser usada en una sentencia <span class="inline">with</span> (explicada <a href="Language_Features/with.htm">aquí</a>), en un <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">evento de colisión</a>, o en una función. Esta sección va a explicar los dos últimos casos de uso.</p>
      <p class="dropspot">Tenga en cuenta que en los eventos que no sean el de colisión, cuando estén fuera de cualquier llamada a una función y de los bloques de <span class="inline">with()</span>, <span class="inline">other</span> simplemente devuelve el <span class="notranslate">struct</span> para la instancia actual.</p>
      <h2 class="dropspot">Evento de colisión</h2>
      <p class="dropspot">Un evento de colisión sólo puede ocurrir entre <strong>dos </strong>instancias. <i>Puedes</i> tener múltiples colisiones entre múltiples instancias, pero todas son resueltas por <span data-keyref="GameMaker Name">GameMaker</span> en una base de 1 a 1, con la instancia &quot;propia&quot; que tiene el evento de colisión y la &quot;otra&quot; instancia que está colisionando con ella.</p>
      <p class="dropspot">Imagina que tienes una instancia de jugador, múltiples instancias de enemigo y múltiples instancias de bala que el enemigo puede disparar contra ti. Puedes asignar a cada enemigo una única instancia de bala pero con una variable de daño diferente asignada aleatoriamente cuando se crea, por ejemplo:</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Puede ver cómo establecemos sus variables utilizando la notación de puntos, como se indica en la sección sobre <a href="Addressing_Variables_In_Other_Instances.htm">la dirección de las variables en otras instancias</a>. Esto dará a cada instancia de bala un valor de daño diferente, pero ¿cómo detectará el jugador el daño que tiene que recibir cuando sea alcanzado por una bala?</p>
      <p class="dropspot">Para ello, el jugador tendrá que tener un evento de colisión con <span class="inline">obj_Bullet</span>, y dentro de ese evento utilizar <span class="inline">other</span> para leer las variables de la instancia de bala que colisiona:</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">El código anterior deducirá la cantidad almacenada en la variable &quot;damage&quot; de la <i>otra</i> instancia de la variable &quot;hp&quot; del jugador, luego comprobará si la &quot;hp&quot; es menor o igual a 0. Si lo es entonces destruirá la instancia del jugador. Ten en cuenta que la otra instancia debe tener la variable que se está comprobando o de lo contrario se producirá un error.</p>
      <p class="note"><strong>NOTA</strong>: El evento Colisión es el único evento que tiene un significado especial para la palabra clave <span class="inline">other</span>. En todos los demás eventos y <span class="notranslate">scripts</span>, el comportamiento de <span class="inline">other</span> estará definido por el contexto en el que se utilice (como un bloque <span class="inline">with() </span>, una función, una declaración <span class="notranslate">struct</span>, etc.).</p>
      <p class="dropspot">Puedes asignar valores a las variables, o incluso crear nuevas, utilizando <span class="inline">other</span> en el evento de colisión, así:</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Declaración Struct</h2>
      <p class="dropspot">Cuando se utiliza dentro de una declaración <span class="notranslate">struct</span>, <span class="inline">other</span> se refiere a la instancia que está inicializando la estructura:</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Sin embargo, no es necesario utilizar <span class="inline">other</span> para leer variables de la instancia, ya que cualquier variable a la que se haga referencia directamente se leerá del ámbito de esa instancia, como se describe <a href="Structs.htm#inst_in_struct">en esta sección</a> del manual. Sólo necesitarías usar esto si quisieras almacenar una referencia a la instancia <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Método de instancia</h2>
      <p class="dropspot">El uso de <span class="inline">other</span> dentro de un método de otra instancia <a href="Method_Variables.htm"><span class="notranslate">method</span></a> se refiere a la instancia que llamó a ese método.</p>
      <p class="dropspot">Por ejemplo, digamos que <span class="inline">Object2</span> tiene un método que hace referencia a <span class="inline">self</span> y <span class="inline">other</span>. Este método es llamado en <span class="inline">Object1</span>. Como el método fue creado en <span class="inline">Object2</span>, está <strong>vinculado</strong> a él y siempre utilizará la instancia <span class="inline">Object2</span> como &quot;yo&quot;, sin importar qué instancia lo llame. En este caso, la instancia que llama se convierte en <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Esto haría que la instancia imprimiera primero su propio nombre <span class="notranslate">object</span> (&quot;Object2&quot;) y luego el nombre <span class="notranslate">object</span> de la instancia que llama (&quot;Object1&quot;).</p>
      <p class="dropspot">Lo mismo ocurrirá con un método vinculado a un <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Función del constructor</h2>
      <p class="dropspot">Cuando se utiliza dentro de una función constructora, <span class="inline">other</span> hará referencia a la instancia que está llamando a esa función, sin embargo, esto no se recomienda para el uso general, ya que cualquier dato externo que un constructor necesita utilizar debe ser pasado como argumentos.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palabra clave</th>
            <th>Descripción</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Todas las instancias actualmente activas en <span class="notranslate">room</span>.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Esta palabra clave se utiliza para decirle a <span data-keyref="GameMaker Name">GameMaker</span> que una función debe ser aplicada, o para comprobar, todas las instancias activas dentro de un <span class="notranslate">room</span> (las instancias desactivadas no serán comprobadas o accedidas). <b>No se puede</b> usar <span class="inline">all</span> para acceder o establecer variables en otras instancias usando el método point (ver <a href="Addressing_Variables_In_Other_Instances.htm">aquí</a>), pero se <strong>puede </strong>usar cuando se llama a <a href="Language_Features/with.htm"><span class="inline">with()</span></a>por ejemplo:</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">El código anterior establecerá la velocidad de todas las instancias en el <span class="notranslate">room</span> a 0. También puede utilizar <span class="inline">all</span> dentro de las funciones para apuntar o comprobar todas las instancias en el <span class="notranslate">room</span> por ejemplo:</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> es una palabra clave muy útil y puede ser utilizada en numerosas situaciones dentro de su código y acciones, a menudo reduciendo la cantidad de código que necesita escribir para lograr un efecto deseado.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palabra clave</th>
            <th>Descripción</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>No hay ninguna instancia.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Puede parecer extraño, pero muchas veces al programar tus juegos te encontrarás con la necesidad de comprobar si no se encuentran instancias en una ubicación, o en una colisión, etc... En esos casos usarás esta palabra clave para comprobar que no hay nada, algo así:</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">En este ejemplo, la función <span class="inline">instance_nearest()</span> devolverá <span class="inline">noone</span> o el ID único de la instancia encontrada más cercana. Básicamente, cada vez que necesites buscar una instancia, puedes esperar que te devuelvan o bien <span class="inline">noone</span> o bien un ID de instancia único.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Atrás: <a href="GML_Overview.htm">Visión general de GML</a></div>
          <div style="float:right">Siguiente: <a data-xref="{title}" href="Evaluation_Order.htm">Orden de evaluación</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos los derechos reservados</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>