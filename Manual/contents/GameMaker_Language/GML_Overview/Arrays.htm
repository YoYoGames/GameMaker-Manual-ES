<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Arrays</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Arrays</h1>
  <p>Los arrays pueden ser extremadamente útiles y son una parte esencial de la creación de juegos. Es esencialmente un tipo de variable que puede contener múltiples valores como una &quot;lista&quot; -- considera el siguiente código:</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>Utilizando la sintaxis <span class="inline2">[ítem, ítem, ítem]</span> estamos creando un array que se almacena en una variable. A los elementos almacenados en un array se puede acceder posteriormente a través de esa variable utilizando un número entero, empezando por <span class="inline">0</span>, que se coloca dentro de los corchetes <span class="inline2">[]</span>:</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">Un array básico se clasifica como de 1 <strong>dimensión</strong>, pero también se pueden tener arrays con más de una dimensión. Las secciones siguientes explican ambos tipos de matrices:</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Matrices unidimensionales</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Antes de seguir adelante, aclaremos qué es un array y cómo está estructurado. Un array es simplemente un <a href="Data_Types.htm">tipo de datos</a> que se asigna a una variable, y puede contener no sólo un valor, sino múltiples valores. La imagen de abajo muestra un esquema de un array básico:</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">Esto se llama un array <strong>1D</strong> (unidimensional), y como puedes ver el array se almacena en la variable &quot;<span class="inline">a</span>&quot; y contiene múltiples valores. Para acceder al array se haría algo como lo siguiente:</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">El código anterior obtiene el valor de la posición 0 de la matriz &quot;<span class="inline">a</span>&quot; y luego lo envía a la consola, que - basándose en el contenido de la matriz mostrada en la imagen anterior - daría 125. Si hicieras lo siguiente</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">La salida mostraría &quot;¡Hola!&quot;.</p>
    <p class="dropspot">Como puedes ver, le das al array un nombre de variable y luego un valor entre corchetes <span class="inline">[]</span>, donde el valor es la posición en el array de donde obtener los datos. Así que esencialmente, un array es un contenedor con un número de ranuras para almacenar valores, y cada posición en el contenedor tiene un número específico para identificarlo, que es lo que ponemos en el <span class="inline">[]</span>. Vale la pena señalar que el contenido de un array <b>siempre comienza en 0</b> y <i>nunca</i>puede <i>ser negativo</i><em>!</em></p>
    <h3 class="dropspot">       Creación de matrices</h3>
    <p class="dropspot">Hemos mostrado cómo comprobar los datos de un array, pero ¿cómo creamos el array para empezar? Primero tiene que ser <i>inicializado</i> antes de que podamos usarlo o <span data-keyref="GameMaker Name">GameMaker</span> nos dará un error. Inicializar un arreglo significa que le damos a cada ranura del arreglo un valor inicial en preparación para que sea usado en otra parte del código del proyecto. Esto es importante de recordar, ya que significa que usted tiene que hacer una cierta cantidad de planificación antes de utilizar las matrices, pero es bastante fácil de inicializar uno usando una repetición <span class="notranslate">loop</span> como este:</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">Este sencillo código inicializará un array de diez ranuras (de 0 a 9) para que contenga 0, es decir, cada ranura del array contiene el valor 0. Notarás que el array ha sido inicializado <i>al revés</i>, con el último valor definido primero. Esto no es estrictamente necesario, pero es la forma óptima de hacerlo, ya que reservará un espacio en la memoria que es el tamaño exacto de la matriz, mientras que si se inicializa una matriz de 0 <em>hacia arriba</em>, la memoria tiene que ser reasignada por cada valor adicional añadido (por lo que para una matriz de diez ranuras, inicializarla en un <span class="notranslate">loop</span> cambiaría la asignación de memoria diez veces). La diferencia de velocidad es insignificante para los arrays más pequeños, pero los más grandes deberían optimizarse al máximo de esta manera.</p>
    <p class="note"><b>NOTA</b>: La exportación de HTML5 es la excepción a la regla anterior, y cuando se dirija a ella deberá inicializar las matrices en orden consecutivo de 0 en adelante.</p>
    <p class="dropspot">También puede utilizar la función <span class="notranslate">GML</span> <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> para inicializar un array con un tamaño fijo, e incluso puedes crear arrays &quot;vacíos&quot; <em>sin</em> valores, por ejemplo:</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">Esto le dice a <span class="notranslate">GameMaker</span> que la variable &quot;<span class="inline">my_array</span>&quot; es un array, y que puede <a href="../GML_Reference/Variable_Functions/array_push.htm">añadirle valores</a> en cualquier momento en el futuro. Sin embargo, si intentas acceder a un valor en un array vacío, obtendrás un error.<br></p>
    <p class="dropspot">Si ya sabes qué elementos quieres poner en la matriz, puedes añadir valores separados por comas entre los paréntesis al declarar la matriz:</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       Límites de la matriz</h3>
    <p class="dropspot">Siempre debe tener cuidado de acceder sólo a las posiciones válidas del array, ya que intentar acceder a un valor fuera de un array también dará un error. Por ejemplo, esto hará que el proyecto se bloquee cuando se ejecute:</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">El array sólo se inicializó con 5 posiciones, pero hemos intentado conseguir la posición 7 -ya que los arrays se numeran desde 0, <span class="inline">array[6]</span> es la posición 7- por lo que el juego genera un error y se bloquea.</p>
    <h3 class="dropspot">       Uso de matrices</h3>
    <p class="dropspot">Ahora bien, ¿cómo utilizamos un array de forma práctica? Exactamente igual que usaríamos una variable normal, como se muestra en los siguientes ejemplos:</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if array[9] == 10<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">Dado que los arrays se numeran secuencialmente, esto significa que puedes <span class="notranslate">loop</span> a través de ellos para realizar acciones adicionales también, al igual que hicimos para inicializarlo:</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), total);
    </p>
    <p class="dropspot">El código anterior sumará todos los valores de nuestra matriz, dibujará cada uno de ellos y luego dibujará el valor total al final.</p>
    <h3 class="dropspot">       Borrar matrices</h3>
    <p class="dropspot">Lo último que hay que mencionar sobre los arrays es que puedes eliminar un array simplemente &quot;reasignando&quot; la variable que lo define a un único valor. Esto liberará la memoria asociada a todas las posiciones y valores de ese array. Por ejemplo:</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = -1;
    </p>
    <p class="dropspot">Si el array tiene múltiples dimensiones (ver más abajo), también se limpiarán todas, y ten en cuenta que cuando creas arrays en instancias, éstos no necesitan ser limpiados cuando la instancia es eliminada del juego, ya que serán eliminados automáticamente por el <a class="glossterm" data-glossterm="recolector de basura" href="#">recolector de</a> basura en Destroy o <span class="notranslate">Room</span> End. Sin embargo, si alguna de las posiciones del array contiene referencias a activos <em>dinámicos</em>, como sistemas de partículas, <span class="notranslate">buffers</span>, o <span class="notranslate">data structures</span>, entonces estos <em>deberán</em> ser destruidos antes de que el array sea eliminado, la instancia sea destruida o el <span class="notranslate">room</span> termine.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Matrices multidimensionales</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">Ahora sabemos lo que es un array de 1 dimensión, pero en <span data-keyref="GameMaker Name">GameMaker</span> puedes tener arrays con múltiples dimensiones, que se estructuran esencialmente como un array dentro de otro array dentro de otro array... Por ejemplo, lo siguiente es un array <strong>2D</strong> (bidimensional):</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">Esto es esencialmente decirle a <span class="notranslate">GameMaker</span> que la matriz se compone en realidad de varias matrices 1D. Aquí hay un ejemplo extendido:</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">En el código anterior, <span class="inline">array[0]</span> contiene otra matriz, al igual que <span class="inline">array[1]</span>.</p>
    <p class="dropspot">Un array multidimensional necesita ser inicializado antes de su uso, al igual que un array 1D, y puede contener números reales, <span class="notranslate">strings</span>, y cualquier otro <a href="Data_Types.htm">tipo de datos</a>, como cualquier variable, lo que los convierte en candidatos ideales para cualquier juego que necesite almacenar grandes cantidades de datos de una forma fácilmente accesible (recuerda que puedes <span class="notranslate">loop</span> a través de un array fácilmente).</p>
    <p class="dropspot">También se puede inicializar un array multidimensional dentro de una sentencia anidando arrays unidimensionales:</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">Las matrices multidimensionales tampoco se limitan <em>a </em>dos dimensiones, y puedes tener 3, 4 o más dimensiones en una matriz según lo requiera tu código, simplemente añadiendo <span class="inline">[n]</span> argumentos adicionales, por ejemplo:</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">También hay que tener en cuenta que la longitud de cada dimensión de un array puede ser diferente, por lo que se puede tener la dimensión inicial del array con una longitud de 3, pero la entrada de la segunda dimensión puede tener una longitud diferente para cada ranura de la primera dimensión; por ejemplo:</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">En el código anterior, <span class="inline">array[0]</span> tiene 2 ranuras, <span class="inline">array[1]</span> tiene 4 ranuras y <span class="inline">array[2]</span> tiene 3 ranuras.</p>
    <h3 class="dropspot">       Ejemplo ampliado</h3>
    <p class="dropspot">He aquí un último ejemplo de cómo se puede utilizar esto en un juego real: Digamos que quieres que aparezcan cuatro enemigos diferentes en cuatro puntos diferentes de tu juego dependiendo de un valor aleatorio. Bien, podemos usar un array con 2 dimensiones para hacer esto y ahorrarnos escribir una carga de código.</p>
    <p class="dropspot">Primero debemos inicializar el array que vamos a utilizar en el evento Create de nuestro &quot;controlador&quot; <span class="notranslate">object</span> (nótese el uso de comentarios para recordar lo que hace cada entrada del array):</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">Ahora tenemos el <span class="notranslate">objects</span> para generar instancias y sus correspondientes coordenadas x e y dentro del <span class="notranslate">room</span> todo almacenado en nuestro array. Esto se puede utilizar ahora de la siguiente manera en otro evento del controlador <span class="notranslate">object</span> (una alarma por ejemplo, o un evento de pulsación de tecla):</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">Ese código corto ahora generará un enemigo al azar en el juego <span class="notranslate">room</span>, y utiliza mucho menos código que una estructura &quot;<span class="inline">if / then / else</span>&quot; o incluso un &quot;<span class="inline">switch</span>&quot;, y como el array se inicializa todo junto en el evento de creación es MUCHO más fácil editar y cambiar cualquiera de esos valores ya que no están <a class="glossterm" data-glossterm="codificado" href="#">codificados</a> en el resto del código del proyecto.</p>
  </div>
  <p> </p>
  <h2>Arreglos como argumentos de funciones</h2>
  <p>Puede pasar arrays a <a href="Script_Functions.htm">las funciones de script</a> y a las <a href="Method_Variables.htm">variables de los métodos</a> como argumentos, y modificar esos arrays en cualquier lugar dentro de la función. Al hacerlo, también se modificarán las matrices originales.</p>
  <p>Por ejemplo, esta función simplemente cambia los tres primeros elementos de la matriz que se le pasa:</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>Ahora puedes crear un array y pasarlo a esta función, que modificará el array:</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>En versiones anteriores de <span class="notranslate">GameMaker</span>, este no era el caso, ya que al modificar un array dentro de una función se creaba una copia en su lugar. Este comportamiento <em>obsoleto</em> aún puede activarse si se desea: lea la sección &quot;<strong>Copiar al escribir</strong>&quot; más adelante para obtener más información.</p>
  <h2 id="h">Copiar en la escritura</h2>
  <p>El comportamiento de Copiar en Escritura está obsoleto, y sólo se utiliza cuando &quot;<strong>Activar el comportamiento de Copiar en Escritura para Arrays</strong>&quot; está activado en las <a href="../../Settings/Game_Options.htm">Opciones Generales del Juego</a>. Esta sección describe el comportamiento de los arrays cuando esta opción está activada.</p>
  <p>Como se ha descrito en la sección anterior, los arrays pueden pasarse a las funciones como argumentos. Para ello, basta con especificar la variable del array (sin necesidad de cada una de las posiciones individuales, ni de los paréntesis de <span class="inline">[]</span> ) y todo el array se <b>pasará por referencia</b> a la función:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>Sin embargo, cuando se activa la función <strong>Copy on Write</strong>, al cambiar cualquier valor del array dentro de la función se crea una copia temporal con sus modificaciones. El array original no se modifica. Este comportamiento se llama Copy on Write.</p>
  <p>Para modificar realmente la matriz original que se pasó a la función, debe devolverla o utilizar el accesorio <span class="inline">@</span>.</p>
  <p>Por ejemplo, la función llamada anteriormente, <span class="inline2">do_something()</span>, puede hacer algo simple como esto:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>Ahora se esperaría que <span class="inline2">mi_array</span> mantuviera los valores <span class="inline2">1, 200, 4</span>, etc., lo que normalmente sería correcto -- pero cuando se habilita <strong>Copiar en Escritura</strong>, el array original no se ve afectado.</p>
  <p>Para evitarlo, puedes hacer que la función <strong>devuelva</strong> la copia modificada del array, y luego aplicarla de nuevo a la variable original:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>La propia función devolvería el array modificado:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">NOTA</span><b> </b>El código anterior no es necesario si no está cambiando ninguno de los valores de la matriz, sino haciendo referencia a ellos. Referenciar un array no lo copiará y será más rápido de analizar.</p>
  <p>La segunda solución es utilizar el accesorio <span class="inline">@</span> para cambiar los valores del array directamente, lo que ahorra la sobrecarga de la CPU de tener que hacer una copia temporal. Esto significa que no necesitas devolver el array desde la función y puedes editarlo directamente:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>El uso de este accesorio omite el comportamiento de Copiar en Escritura y modifica directamente el array referenciado. Esto se puede utilizar para deshabilitar selectivamente Copy on Write para declaraciones específicas mientras se mantiene la opción habilitada.</p>
  <p>Nuevamente, todo esto no es necesario si la opción <strong>Copiar al escribir</strong> está <strong>desactivada</strong> (que es la opción por defecto y recomendada).</p>
  <p>En la siguiente página encontrarás más información sobre los accesores y su funcionamiento, junto con un ejemplo de arrays:</p>
  <ul class="colour">
    <li><a href="Accessors.htm">Accesos</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Atrás: <a href="GML_Overview.htm">Visión general de GML</a></div>
        <div style="float:right">Siguiente: <a data-xref="{title}" href="Structs.htm">Estructuras y constructores</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos los derechos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>